# rum
	Yusra Suhail, Amelia Vogel, Lakshinee Rungadoo
For this assignment, we spent approximately 17 hours in total to implement our Universal Machine. We spent a lot of time in help hours and we consulted with both the professor and the TAs at several points throughout the process of coding our UM. We spent the longest amount of time in Eddy’s hours as well as Professor Daniels’; we also attended other TA hours such as Colin’s and Derek’s that were also very helpful.
While creating the Design Document for this assignment, we were most confused about how to organize the different modules in order to emulate the functionality of a Universal Machine. Initially, we were confused on how to start coding a UM since we were unsure on how to connect all the components to emulate a Universal Machine. However, once we got some advice from Professor Daniels and we worked through the labs where we created programs to use for testing, we were able to get a head start on our machine.
While attempting to implement this Universal Machine, we struggled a lot with the abstraction part as we tried to figure out how to best represent the working parts of a machine in Rust. A lot of the issues we encountered involved referencing and dereferencing pointers and structs/mods since we decided to create an instance of a machine that we passed into the program; this explicit definition limited our options in terms of structuring the code as well as figuring out alternate solutions to the problem. 
Our final submission to Gradescope passes all the visible tests, and we have also tested our code with the programs we created in the labs. Our implementation of the machine did not end up being too different from the one that we described in our Design Document, except for the fact that we did not end up creating an emulation module. Instead, we chose to have a rumload module along with our other modules: main, instructions, structures, and  seg_operations.
Upon execution, our Universal Machine runs by creating an instance of a machine. Our machine has registers, segmented memory, program counter, a pool of unused IDs which help us to keep track of which segments to map and unmap. It also has a segment_id for each segment. We load our program so that we can read the file from stdin and instructions from that file. We load it by calling our rumload module. This module has only a rumload function which is public so that main can call it.
The instructions given to our program are then saved to the segment of the machine. We then create an infinite loop, so that our machine can keep executing instructions till the machine encounters a halt instruction. 


The instruction module only knows about the machine and the instructions given by the user.  This module then parses every instruction passed to it from the main. It figures out which opcode the instruction has and then calls the seg_operation modulus’s respective function. These functions know about the opcode passed to it and the registers, or values associated with that instruction and nothing else. The parse_opcode function in this module is public so that main can call it. But the functions to extract the registers and opcodes are private to that module. 
The seg_operations module then executes the instructions depending on which opcode it got. The functions in this module are public so that the instructions module can call them. 
The structures module has all the structures, types and enums necessary for our program. All of the structs in these modules are public so other modules can access it. 
Before we started both the design and the implementation of this assignment, we spent a lot of time analyzing it. Aforementioned, we had a lot of trouble envisioning our solution for this assignment due to the level of abstraction involved. As such, we probably spent around 2-3 hours—if not more—analyzing the assignment both prior to creating the design doc and our implementation as well as during. We got stuck a lot and we found ourselves needing to reread the assignment handout a lot as we struggled to understand what was being asked of us and how to implement it. 
We spent approximately 5 hours on our design document; the actual drafting of the document did not take long, but it took us a while to understand the assignment and figure out how we would approach the solution. We spent most of the drafting process asking questions and attending help hours of both Professor Daniels and several TAs. 
It took us quite a while to solve the problems presented in this assignment; we probably spent around 8-10 hours coding our solution. A lot of it was trial and error since we had to turn the instructions we received in the assignment handout into pseudocode and then translate that into Rust; we struggled a lot here, since it was tricky managing the different modules and referencing/dereferencing the Universal Machine. The rest of our time was spent debugging and stepping through the code in order to understand where the wrong operation was occurring.
